void printBinaryDigest(byte (&value)[16]){

    for(int i=0;i<16;i++){
        std::bitset<8> a(value[i]);
        std::cout<<a.to_string()<<std::endl;
    }
}

void printBinary(std::string value){

    for (std::size_t i = 0; i < value.size(); ++i)
    {
        std::cout << std::bitset<8>(value.c_str()[i]) << std::endl;
    }

}

template<typename T>
void printBinaryOneLine(T value,bool delim){
    printBinary(value,"");
    if(delim){
        std::cout<<"\n"<<"---------------"<<std::endl;
    }else{
        std::cout<<std::endl;
    }
}

void printBinaryByLine(std::string value){
    printBinary(value);
    std::cout<<"---------------"<<std::endl;
}


-------------------------------------------

    byte digest[ CryptoPP::Weak::MD5::DIGESTSIZE ];
    byte digest2[ CryptoPP::Weak::MD5::DIGESTSIZE ];
    byte digest3[ CryptoPP::Weak::MD5::DIGESTSIZE ];

    std::string message = "129";

    CryptoPP::Weak::MD5 hash;


    hash.CalculateDigest( digest, (const byte*)message.c_str(), message.length() );


    for(int i=0;i<3333;i++){

        hash.CalculateDigest( digest2, digest, 16 );
        hash.CalculateDigest( digest3, digest2, 16 );
        hash.CalculateDigest( digest, digest3, 16 );

    }

    CryptoPP::HexEncoder encoder;
    std::string output;


    encoder.Attach( new CryptoPP::StringSink( output ) );
    encoder.Put( digest, sizeof(digest) );
    encoder.MessageEnd();

    std::transform(output.begin(), output.end(), output.begin(), [](unsigned char c){ return std::tolower(c); });

    std::cout << output << std::endl;

     helper::printBinaryDigest(digest);
     std::cout<<"----------------------"<<std::endl;

////test of decoded hash
////and conversion to digest

    std::string encoded = "da8c2466069eac1b1f4d641f8cb02fed";
    std::string decoded;

    byte hashToCompare[CryptoPP::Weak::MD5::DIGESTSIZE];

    CryptoPP::HexDecoder decoder;

    decoder.Attach( new CryptoPP::StringSink( decoded ) );
    decoder.Put( (byte*)encoded.data(), encoded.size() );
    decoder.MessageEnd();

    for (int j = 0; j <16 ; ++j) {
        hashToCompare[j]=(byte)decoded[j];
    }
//    compare digests

    for (int k = 0; k <16 ; ++k) {
        if(hashToCompare[k]!=digest[k]){
            std::cout<<"false"<<std::endl;
        }

    }
4digits
ed639398fec9f69e1fa62f9a76e8c37e
9c4ef284c5097d93aed0ccec262c8410
1158988292c1509c3547a7455e9b5afd
0e2ec97a03d9aef4a7da5fcf471a4116
0ecf18da364a12c14f1cbe88842ab0c5
a54cd896faa05c195fb06a9a54fdd083
2f6e4b31aad57e893e87d29011195a71